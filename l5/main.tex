\documentclass{article}
\usepackage{mathtools}

\title{Lista 5}
\author{Caio Ian R. S. Melo}
\date{\today}

\begin{document}

\maketitle

\section{}
Determinar qual o algorítmo ótimo para a resolução de um problema. Medimos a complexidade frente a parte que demanda mais recursos computacionais em um software como processamento ou uso de memória. Por exemplo em uma busca, verifica-se que percorrer a estrutura de dados é muito mais custoso que uma operação algébrica como somar e multiplicar, então esse é o ponto chave que demanda uma maior atenção do programador na hora do desenvolvimento.

\section{}

Considerando que hajam ``n'' elementos nas estruturas de dados a seguir:

\begin{itemize}
\item $\mathcal{O}(n)$, isso acontece caso a inserção seja feita sempre percorrento toda a lista para a ao invés de $\mathcal{O}$(1) que seria no inicio dela.
\item $\mathcal{O}(n)$, ocorrerá quando o elemento distar toda a lista de onde se começa a percorrê-la. Pode-se diminuir esse problema subdividido-a e comparando a lista paralelamente em outras threads para amenizar a situação, mas, há sempre a chance de se ``cair'' no pior caso citado anteriormente, por isso outras estruturas dados são recomendadas quanto é necessário uma maior velocidade de busca.
\item  Para o caso de uma árvore binária cheia $\mathcal{O}(\log_{2}n)$, já para uma árvore genérica com n ``galhos'', $\mathcal{O}(\log_{k}n)$, onde k seria a quantidade de ``galhos'' que a árvore possui. As complexidades citadas anteriormente seriam para árvores ``balanceadas'', pois, no pior caso uma árvore seria apenas uma lista encadeada e portando a complexidade de busca seria $\mathcal{O}(n)$, para resolver esse problema utiliza-se o ``balanceamento'' frequentemente após um certo número de inserções ou remoções.
\end{itemize}

\pagebreak
\section{}

\begin{itemize}
\item $\mathcal{O}(\frac{n}{2}\log_{2}n)$.
\item $\mathcal{O}(n\log_{2}n)$.
\end{itemize}

\end{document}
